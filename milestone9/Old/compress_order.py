#
# Intercom_minimal
# |
# +- Intercom_buffer
# |
# +- Compress

# TODO: Medir el tamaño en bytes del chunk que se envía.
# TODO: Reorganizar indata, convertir las columnas en filas y las filas en columnas antes de comprimir.
# TODO: Reorganizar chunk después de descomprimirlo, volver a la estructura original.

from intercom_buffer import Intercom_buffer
import sounddevice as sd
import numpy as np
import psutil
import time
from multiprocessing import Process
import struct as st
import math
import zlib as z

# Accumulated percentage of used CPU. 
CPU_total = 0

# Number of samples of the CPU usage.
CPU_samples = 0

# CPU usage average.
CPU_average = 0

class Compress_order(Intercom_buffer):

    def init(self, args):
        Intercom_buffer.init(self, args)
        print(args.buffering_time)
        print(f"Compress_order: chunks_to_buffer={self.chunks_to_buffer}")
        print(f"Compress_order: cells_in_buffer={self.cells_in_buffer}")

        # Running the user pacifier.
        p = Process(target=self.feedback)
        p.start()

    #Override decompress.
    def receive_and_buffer(self):
        message = self.receive()
        #tmp = np.frombuffer(message, dtype=np.int16).reshape(self.frames_per_chunk+1, self.number_of_channels)
        (chunk_number,) = st.unpack('!H', message[:2]) 
        chunk = message[2:]
        chunk = z.decompress(chunk) 
        chunk = np.frombuffer(chunk, np.int16).reshape(self.frames_per_chunk, self.number_of_channels)
        self._buffer[chunk_number % self.cells_in_buffer] = chunk
        return chunk_number

    #Override compress. 
    def record_send_and_play(self, indata, outdata, frames, time, status):
        self.recorded_chunk_number = (self.recorded_chunk_number + 1) % self.CHUNK_NUMBERS
        tmp = z.compress(indata)
        tmp = st.pack("!H", self.recorded_chunk_number) + tmp
        self.send_chunk(tmp)
        self.play_chunk(outdata)

    # Runs the intercom and implements the buffer's logic.
    def run(self):
        
        # Buffer creation.
        self._buffer = [None] * self.cells_in_buffer
        for i in range(self.cells_in_buffer):
            self._buffer[i] = self.empty_chunk

        # Chunks counters.
        self.recorded_chunk_number = 0
        self.played_chunk_number = 0

        print("Compress: press <CTRL> + <c> to quit")
        print("Compress: buffering ... ")

        with sd.Stream(samplerate=self.frames_per_second, blocksize=self.frames_per_chunk, dtype=self.sample_type, channels=self.number_of_channels, callback=self.record_send_and_play):
            first_received_chunk_number = self.receive_and_buffer()
            self.played_chunk_number = (first_received_chunk_number - self.chunks_to_buffer) % self.cells_in_buffer
            while True:
                self.receive_and_buffer()

    # Shows CPU usage.
    def print_feedback_message(self):
        # Be careful, variables updated only in the subprocess.
        global CPU_total
        global CPU_samples
        global CPU_average
        CPU_usage = psutil.cpu_percent()
        CPU_total += CPU_usage
        CPU_samples += 1
        CPU_average = CPU_total/CPU_samples
        print(f"{int(CPU_usage)}/{int(CPU_average)}", flush=True, end=' ')

    # This method runs in a different process to the intercom, and its
    # only task is to print the feedback messages with the CPU load,
    # waiting for the interrupt signal generated by the user (CTRL+C).
    def feedback(self):
        global CPU_average
        try:
            while True:
                self.print_feedback_message()
                time.sleep(1)
        except KeyboardInterrupt:
            print(f"\nCompress_order: average CPU usage = {CPU_average} %")

    def add_args(self):
        parser = Intercom_buffer.add_args(self)
        return parser

if __name__ == "__main__":
    intercom = Compress_order()
    parser = intercom.add_args()
    args = parser.parse_args()
    intercom.init(args)
    try:
        intercom.run()
    except KeyboardInterrupt:
        print("Compress: goodbye ¯|_(ツ)_|¯")